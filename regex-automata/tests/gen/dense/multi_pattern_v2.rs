// DO NOT EDIT THIS FILE. IT WAS AUTOMATICALLY GENERATED BY:
//
//     regex-cli generate serialize dense regex MULTI_PATTERN_V2 tests/gen/dense/ --rustfmt --safe --starts-for-each-pattern --specialize-start-states --start-kind both --unicode-word-boundary --minimize \b[a-zA-Z]+\b (?m)^\S+$ (?Rm)^\S+$
//
// regex-cli 0.0.1 is available on crates.io.

use regex_automata::{
    dfa::{dense::DFA, regex::Regex},
    util::{lazy::Lazy, wire::AlignAs},
};

pub static MULTI_PATTERN_V2: Lazy<Regex<DFA<&'static [u32]>>> =
    Lazy::new(|| {
        let dfafwd = {
            static ALIGNED: &AlignAs<[u8], u32> = &AlignAs {
                _align: [],
                #[cfg(target_endian = "big")]
                bytes: *include_bytes!("multi_pattern_v2_fwd.bigendian.dfa"),
                #[cfg(target_endian = "little")]
                bytes: *include_bytes!(
                    "multi_pattern_v2_fwd.littleendian.dfa"
                ),
            };
            DFA::from_bytes(&ALIGNED.bytes)
                .expect("serialized forward DFA should be valid")
                .0
        };
        let dfarev = {
            static ALIGNED: &AlignAs<[u8], u32> = &AlignAs {
                _align: [],
                #[cfg(target_endian = "big")]
                bytes: *include_bytes!("multi_pattern_v2_rev.bigendian.dfa"),
                #[cfg(target_endian = "little")]
                bytes: *include_bytes!(
                    "multi_pattern_v2_rev.littleendian.dfa"
                ),
            };
            DFA::from_bytes(&ALIGNED.bytes)
                .expect("serialized reverse DFA should be valid")
                .0
        };
        Regex::builder().build_from_dfas(dfafwd, dfarev)
    });
